%YAML 1.2
---
name: Osprey
file_extensions: [osp]
scope: source.osprey

variables:
  ident: '\\?[\p{L}_][\p{L}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Cf}_]*'
  ident_no_kw: '(?!(?>a(?>bstract|nd|sync)|b(?>ase|reak)|c(?>atch|lass|onst)|do|e(?>lse|num)|f(?>alse|inally|or|unction)|global|i(?>f|nheritable|n|s|ter)|n(?>amespace|ew|ext|ot|ull)|o(?>perator|r|verridable|verride)|p(?>rivate|rotected|ublic)|r(?>efeq|ef|eturn)|static|t(?>his|hrow|rue|ry|ypeof)|use|var|w(?>hile|ith)|xor|yield)\b){{ident}}'

contexts:
  prototype:
    - include: comment

  main:
    - include: namespace_contents

  tokens:
    - meta_include_prototype: false
    - include: string
    - include: char
    - include: number
    - include: keyword
    - include: identifier
    - include: punctuation

  comment:
    - meta_include_prototype: false
    - match: '///.{0,90}(.*)'
      scope: comment.line.double-slash.documentation.osprey
      captures:
        1: comment.line.double-slash.documentation.excess.osprey
    - match: '/\*\*(?!/)'
      push: block_doc_comment
    - match: '//.*'
      scope: comment.line.double-slash.osprey
    - match: '/\*'
      push: block_comment

  block_doc_comment:
    - meta_include_prototype: false
    - meta_scope: comment.block.documentation.osprey
    - match: '\*/'
      pop: true

  block_comment:
    - meta_include_prototype: false
    - meta_scope: comment.block.osprey
    - match: '\*/'
      pop: true

  string:
    - meta_include_prototype: false
    # Verbatim string literal: r"..."
    - match: '[rR]"'
      push: verbatim_string
    # Regular string literal: "..."
    - match: '"'
      push: regular_string

  verbatim_string:
    - meta_include_prototype: false
    # Triple-quoted string is the closest match I could find
    - meta_scope: string.quoted.triple.osprey
    # The only escape sequence inside verbatim strings is ""
    - match: '""'
      scope: constant.character.escape.osprey
    - match: '"(?!")'
      pop: true

  regular_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.osprey
    - include: escape
    - match: '"'
      pop: true

  escape:
    - meta_include_prototype: false
    - match: '\\(?>["''\\0abnrt_-]|u\h{4}|U\h{8})'
      scope: constant.character.escape.osprey

  char:
    - meta_include_prototype: false
    # Character literal: 'x' (technically only one character, but the regex here allows any number)
    - match: ''''
      push: char_literal

  char_literal:
    - meta_include_prototype: false
    - meta_scope: string.quoted.single.osprey
    - include: escape
    - match: ''''
      pop: true

  number:
    - meta_include_prototype: false
    # Hexadecimal number
    - match: '0[xX]\h+(?:_\h+)*[uU]?'
      scope: constant.numeric.osprey
    # Decimal number (integer and real)
    - match: '[0-9]+(?:_[0-9]+)*(?:\.[0-9]+(?:[eE][+-]?[0-9]+)?|[kKgGmMtT]?[uU]?)?'
      scope: constant.numeric.osprey

  keyword:
    - meta_include_prototype: false
    # Control flow keywords
    - match: '(?>break|catch|do|else|finally|for|if|next|return|throw|try|while|with|yield)\b'
      scope: keyword.control.osprey
    # Keyword operators
    - match: '(?>and|in|is|not|or|refeq|ref|typeof|xor)\b' # Don't reorder ref and refeq; atomic group!
      scope: keyword.operator.osprey
    # Keyword constants
    - match: '(?>false|null|true)\b'
      scope: constant.language.osprey
    # Language variables - this and base
    - match: '(?>base|this)\b'
      scope: variable.language.osprey
    # Storage types
    - match: '(?>class|const|enum|function|namespace|var)\b'
      scope: storage.type.osprey
    # Extension keywords
    - match: '__(?>extern|get_argc|init_type|named_const|primitive)\b'
      scope: keyword.extension.osprey
    # Other keywords
    - match: '(?>abstract|global|inheritable|iter|new|operator|overridable|override|private|protected|public|static|use)\b'
      scope: keyword.other.osprey
    # Reserved keywords
    - match: 'async\b'
      scope: invalid.illegal.keyword.osprey

  identifier:
    - meta_include_prototype: false
    # Type name (probably, anyway; if you follow good style!)
    - match: '\\?[\p{Lu}][\p{L}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Cf}_]*'
      scope: support.class.osprey
    # Identifier (regular or escaped)
    - match: '{{ident}}'
      scope: variable.other.osprey

  punctuation:
    - meta_include_prototype: false
    # @ followed by (
    - match: '(@)\s*(\()'
      captures:
        1: keyword.operator.at.osprey
        2: meta.brace.round.open.osprey
      push: parameter_list
    # @ followed by identifier - the identifier is a parameter name
    - match: '(@)\s*({{ident_no_kw}})'
      captures:
        1: keyword.operator.at.osprey
        2: variable.parameter.osprey
    # @
    - match: '@'
      scope: keyword.operator.at.osprey
    # ? - treated specially, so we can highlight ':' correctly only when part of a conditional expression
    - match: '\?(?![.\[\(?!])'
      scope: keyword.operator.osprey
      push: conditional_expression
    # Various operators
    - match: '~|[+|/%&^#$!=]=?|-[>=]?|\*\*?=?|<=>|>>?=?|<<?=?|::=?|\?[?!]|=>'
      scope: keyword.operator.osprey
    # Brackets
    - match: '\('
      scope: meta.brace.round.open.osprey
      push: parenthesis
    - match: '\['
      scope: meta.brace.square.open.osprey
      push: square_bracket
    - match: '\{'
      scope: meta.brace.curly.open.osprey
      push: curly_brace

  conditional_expression:
    - match: ':'
      scope: keyword.operator.osprey
      pop: true
    - include: tokens

  parenthesis:
    - match: '\)'
      scope: meta.brace.round.close.osprey
      pop: true
    - include: tokens

  square_bracket:
    - match: '\]'
      scope: meta.brace.square.close.osprey
      pop: true
    - include: tokens

  curly_brace:
    - match: '\}'
      scope: meta.brace.curly.close.osprey
      pop: true
    - include: tokens

  namespace_contents:
    - include: namespace_definition
    - include: class_definition
    - include: enum_definition
    - include: function_definition
    - match: '!'
      scope: keyword.operator.osprey
      push: annotation
    - include: tokens

  namespace_definition:
    - meta_include_prototype: false
    - match: 'namespace\b'
      scope: storage.type.osprey
      push: namespace_definition_meta

  namespace_definition_meta:
    - match: '\{'
      scope: meta.brace.curly.open.osprey
      set: namespace_body
    - match: ';'
      pop: true
    - match: '{{ident_no_kw}}'
      scope: entity.name.namespace.osprey
    - include: tokens

  namespace_body:
    - meta_scope: meta.namespace.body.osprey
    - match: '\}'
      scope: meta.brace.curly.close.osprey
      pop: true
    - include: namespace_contents

  class_definition:
    - meta_include_prototype: false
    - match: '(?:(class)|(inheritable))\s+({{ident_no_kw}})'
      scope: meta.class.osprey
      captures:
        1: storage.type.osprey
        2: keyword.other.osprey
        3: entity.name.type.class.osprey
      push: class_definition_meta

  class_definition_meta:
    - match: '\{'
      set: class_body
    - include: tokens

  class_body:
    - meta_scope: meta.class.body.osprey
    # Property accessor declaration
    - match: '(get|set)\s+(?:({{ident_no_kw}})|(this\b))'
      scope: meta.property.osprey
      captures:
        1: keyword.other.osprey
        2: entity.name.property.osprey
        3: keyword.other.osprey
      push: property_definition
    # Type initializer (non-standard extension)
    - match: '(__init_type)\s*(\()'
      captures:
        1: keyword.extension.osprey
        2: meta.brace.round.open.osprey
      push: parenthesis
    # Method declaration
    - match: '(?:({{ident_no_kw}})|(new|this)\b)\s*(\()'
      scope: meta.function.osprey
      captures:
        1: entity.name.function.osprey
        2: keyword.other.osprey
        3: meta.brace.round.open.osprey
      push: [method_body, parameter_list]
    # Field or constant declaration
    - match: '({{ident_no_kw}})(?!\s*\()'
      scope: entity.name.field.class.osprey
      push: field_definition
    # Operator overload declaration
    - match: '(operator)\s*([~+-|^/%&#$]|\*\*?|<(?:<|=>)|>>?|==)\s*(\()'
      captures:
        1: keyword.other.osprey
        2: entity.name.operator.osprey
        3: meta.brace.round.open.osprey
      push: [method_body, parameter_list]
    # Iterator declaration
    - match: 'iter\b'
      scope: meta.iterator.osprey keyword.other.osprey
      push: method_body
    # Annotation
    - match: '!'
      scope: keyword.operator.osprey
      push: annotation
    # Other stuff
    - include: tokens
    # End of class
    - match: '\}'
      scope: 'meta.brace.curly.close.osprey'
      pop: true

  property_definition:
    - meta_scope: meta.class.member.property.osprey
    # Indexer accessor parameter list
    - match: '\['
      scope: meta.brace.square.open.osprey
      push: indexer_parameter_list
    # Property accessor with expression getter
    - match: '='
      scope: keyword.operator.osprey
      set: property_expr_body
    # Property accessor with block body
    - match: '\{'
      scope: meta.brace.curly.open.osprey
      set: property_block_body
    # Property accessor without a body (probably abstract)
    - match: ';'
      pop: true
    # This might screw up syntactically broken property accessor definitions,
    # but it'll be okay
    - include: tokens

  indexer_parameter_list:
    - meta_scope: meta.class.member.property.osprey
    - match: '\]'
      scope: meta.brace.square.close.osprey
      pop: true
    # Unlike parameter_list, an indexer accessor parameter list can only contain "simple"
    # parameters, i.e. plain identifiers. For performance, inline the members of 'tokens'.
    - include: string
    - include: char
    - include: number
    - include: keyword
    - match: '{{ident}}'
      scope: variable.parameter.osprey
    - include: identifier
    - include: punctuation

  property_expr_body:
    - meta_scope: meta.class.member.property.osprey
    - match: ';'
      pop: true
    # Good enough
    - include: tokens

  property_block_body:
    - meta_scope: meta.class.member.property.osprey
    - include: curly_brace

  method_body:
    - meta_scope: meta.class.member.method.osprey
    # Block body
    - match: '\{'
      scope: meta.brace.curly.open.osprey
      set: method_block_body
    # No body (probably abstract)
    - match: ';'
      pop: true
    # Allow extension keywords to be used as well
    - include: tokens

  method_block_body:
    - meta_scope: meta.class.member.method.osprey
    - include: curly_brace

  field_definition:
    # End of definition
    - match: ';'
      pop: true
    # Field with value
    - match: '='
      scope: keyword.operator.osprey
      set: field_value
    # Another field name (hopefully after a comma)
    - match: '{{ident_no_kw}}'
      scope: entity.name.field.class.osprey
    # Comma needs no special treatment here; they just continue the field definition
    - include: tokens

  field_value:
    - meta_scope: meta.class.member.field.osprey
    # After a comma, there might be another field
    - match: ','
      set: field_definition
    # After a semicolon, not so much
    - match: ';'
      pop: true
    - include: tokens

  annotation:
    - meta_scope: meta.annotation.osprey
    # The rules gets a bit messy here... basically, allow keywords, '.', ':', identifier
    # and '('. If we find anything else, including EOL, it's the end of the annotation.
    # ':' is permitted so that annotations like "!global: Foo" can be highlighted correctly.
    # Note: annotations are not actually required to be on a single line, but it's the
    # convention, and I haven't found a more reliable way to highlight this...
    - include: keyword
    - include: identifier
    # No scope for these
    - match: '[.:]'
    # Arguments to the constructor; optional
    - match: '\('
      scope: meta.brace.round.open.osprey
      set: annotation_arguments
    # End of line, or anything else that isn't whitespace
    - match: '(?=$|\S)'
      pop: true

  annotation_arguments:
    - meta_scope: meta.annotation.osprey
    - include: parenthesis

  enum_definition:
    - meta_include_prototype: false
    - match: '(enum(?:\s+set)?)\s+({{ident_no_kw}})'
      scope: meta.class.osprey
      captures:
        1: storage.type.osprey
        2: entity.name.type.enum.osprey
      push: enum_definition_meta

  enum_definition_meta:
    - match: '\{'
      scope: meta.brace.curly.open.osprey
      set: enum_body
    - include: tokens

  enum_body:
    - match: '\}'
      scope: meta.brace.curly.close.osprey
      pop: true
    - match: '{{ident_no_kw}}'
      scope: entity.name.field.enum.osprey
      set: enum_field_definition
    - match: '!'
      scope: keyword.operator.osprey
      push: annotation
    - include: tokens

  enum_field_definition:
    - match: '\}'
      scope: meta.brace.curly.close.osprey
      pop: true
    - match: ','
      set: enum_body
    - match: '='
      scope: keyword.operator.osprey
      set: enum_field_value
    - include: tokens

  enum_field_value:
    - match: '\}'
      scope: meta.brace.curly.close.osprey
      pop: true
    - match: ','
      set: enum_body
    - include: tokens

  function_definition:
    - match: '(function)\s+({{ident_no_kw}})\s*(\()'
      scope: meta.function.osprey
      captures:
        1: storage.type.osprey
        2: entity.name.function.osprey
        3: meta.brace.round.open.osprey
      push: [method_body, parameter_list]

  parameter_list:
    - match: '\)'
      scope: meta.brace.round.close.osprey
      pop: true
    - match: '='
      scope: keyword.operator.osprey
      set: default_parameter_value
    # Same as 'tokens', but with special handling for identifiers
    - include: string
    - include: char
    - include: number
    - include: keyword
    - match: '{{ident}}'
      scope: variable.parameter.osprey
    - include: identifier
    - include: punctuation

  default_parameter_value:
    - match: ','
      set: parameter_list
    - match: '\)'
      scope: meta.brace.round.close.osprey
      pop: true
    - include: tokens
...
